//
//  File.swift
//  
//
//  Created by Kevin Kelly on 9/2/24.
//

import Foundation

/// A source of `Task` timeline events.
///
/// Should be on each source, but with different signatures:
/// - `create() -> Self`
/// - `edit() -> Self`
public protocol TaskSource: Codable, Identifiable, Equatable {
    /// The type of task generated by this task source.
    associatedtype AssociatedTask: Task
    /// The unique ID of the task source.
    var id: Key { get }
    /// The label of the task source.
    var label: String { get }
    /// The description of the task source.
    var description: String? { get }
    /// The category of the task source, for organizing and applying pauses.
    var category: Key? { get }
    /// The pauses for a task source. Will override any category pauses.
    var pauses: [Key]? { get }
    /// When a source was deactived. Seperate from pauses.
    var deactivated: Date? { get }
    /// Deactivate a task, if not already deactivated.
    func deactivate(date: Date?) -> Self
    /// Activate a task if deactivated.
    func activate() -> Self
    /// When a task is completed, it is passed back to the source to create the next task.
    func generateNewTask(from completedTask: AssociatedTask) -> AssociatedTask?
}

extension TaskSource {
    /// Generic trampoline function into type specific `generateNewTask()`
    public func generateNewTask(from task: any Task) -> (any Task)? {
        guard let task = task as? Self.AssociatedTask else { return nil }
        return self.generateNewTask(from: task)
    }
    
    public var active: Bool { deactivated == nil }
}

/// A codable, type erased `Task` container
public final class AnyTaskSource: TaskSource {
    public typealias AssociatedTask = AnyTask
    public var id: Key { data.id }
    public var label: String { data.label }
    public var description: String? { data.description }
    public var category: Key? { data.category }
    public var pauses: [Key]? { data.pauses }
    public var deactivated: Date? { data.deactivated }
    
    public func generateNewTask(from completedTask: AnyTask) -> AnyTask? {
        guard let newTask = data.generateNewTask(from: completedTask.task) else { return nil }
        return AnyTask(newTask)
    }
    
    public func deactivate(date: Date?) -> AnyTaskSource {
        let newSource = data.deactivate(date: date)
        return AnyTaskSource(newSource)
    }
    
    public func activate() -> AnyTaskSource {
        let newSource = data.activate()
        return AnyTaskSource(newSource)
    }

    public var task: any TaskSource { data as (any TaskSource) }
    
    public init(_ task: any TaskSource) {
        self.data = task as! any TaskSourceCodable
    }
    
    public static func == (lhs: AnyTaskSource, rhs: AnyTaskSource) -> Bool {
        lhs.code == rhs.code
    }
    
    
    internal let data: any TaskSourceCodable
    internal var code: TaskSourceCode { data.code }
}

/// This allows `any Task` to be coded as an `AnyTask`
internal protocol TaskSourceCodable: TaskSource {
    var code: TaskSourceCode { get }
}

internal enum TaskSourceCode: Codable, Equatable {
    case toDo(ToDoSource)
    case recurring(ReccuringSource)
}

extension AnyTaskSource {
    internal convenience init(code: TaskSourceCode) {
        switch code {
        case .toDo(let toDoTask): self.init(toDoTask)
        case .recurring(let reccuringTask): self.init(reccuringTask)
        }
    }
    
    internal enum CodingKeys: String, CodingKey {
        case code
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(data.code, forKey: .code)
    }
    
    public convenience init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let code = try container.decode(TaskSourceCode.self, forKey: .code)
        self.init(code: code)
    }
}

